#ifndef MODBUS_TCP_REGISTERS_H
#define MODBUS_TCP_REGISTERS_H

#include <stdint.h>

#define REG_TYPE_HOLDING_REGISTER 0x01
#define REG_TYPE_INPUT_REGISTER   0x02
#define REG_TYPE_COIL             0x04
#define REG_TYPE_ALL              0x07

#define HOLDING_REGISTERS_SIZE 20
#define INPUT_REGISTERS_SIZE   100
#define COILS_REGISTERS_SIZE   10

extern uint16_t holding_regs_database[HOLDING_REGISTERS_SIZE];
extern uint16_t input_regs_database[INPUT_REGISTERS_SIZE];
extern uint8_t  coil_regs_database[COILS_REGISTERS_SIZE];
extern uint8_t  mb_tcp_init_flag;

typedef enum
{
    MB_OK                        = 0x00,
    MB_ERR_NOT_WRITEABLE         = 0x01,
    MB_ERR_OUT_OF_RANGE          = 0x02,
    MB_ERR_TYPE                  = 0x04,
    MB_ERR_ACQUIRE_MUTEX_TIMEOUT = 0x08,
    MB_ERR_NULL_POINTER          = 0x10,
    MB_ERR_FILE_OPERATION        = 0x20,
    MB_ERR_WRITE_FLASH           = 0x40,
	MB_ERR_DEFAULT_FAIL          = 0x41
} mb_err_t;

typedef struct
{
    uint16_t idx;
    uint8_t  type;
    uint16_t address;
    uint16_t default_value;
} mb_reg_t;

enum {
    REG_STM_RST = 0,
    MB_COIL_REG_NUM
};

static const mb_reg_t MB_COIL_REGISTERS[MB_COIL_REG_NUM] = {
    {REG_STM_RST, REG_TYPE_COIL, 0, 0},
};

enum {
    REG_SYSTEM_VERSION = 0,

    REG_C0_STATION_ONLINE,
    REG_C0_ENCODER_ONLINE,
    REG_C0_UPDATE_TIMESTAMP_H,
    REG_C0_UPDATE_TIMESTAMP_L,
    REG_C0_SLEWING_CIRCLE,
    REG_C0_SLEWING_SINGLETURN,
    REG_C0_TROLLEY_CIRCLE,
    REG_C0_TROLLEY_SINGLETURN,
    REG_C0_HOOK_CIRCLE,
    REG_C0_HOOK_SINGLETURN,

    REG_C1_STATION_ONLINE,
    REG_C1_ENCODER_ONLINE,
    REG_C1_UPDATE_TIMESTAMP_H,
    REG_C1_UPDATE_TIMESTAMP_L,
    REG_C1_SLEWING_CIRCLE,
    REG_C1_SLEWING_SINGLETURN,
    REG_C1_TROLLEY_CIRCLE,
    REG_C1_TROLLEY_SINGLETURN,
    REG_C1_HOOK_CIRCLE,
    REG_C1_HOOK_SINGLETURN,

    REG_C2_STATION_ONLINE,
    REG_C2_ENCODER_ONLINE,
    REG_C2_UPDATE_TIMESTAMP_H,
    REG_C2_UPDATE_TIMESTAMP_L,
    REG_C2_SLEWING_CIRCLE,
    REG_C2_SLEWING_SINGLETURN,
    REG_C2_TROLLEY_CIRCLE,
    REG_C2_TROLLEY_SINGLETURN,
    REG_C2_HOOK_CIRCLE,
    REG_C2_HOOK_SINGLETURN,

    REG_C3_STATION_ONLINE,
    REG_C3_ENCODER_ONLINE,
    REG_C3_UPDATE_TIMESTAMP_H,
    REG_C3_UPDATE_TIMESTAMP_L,
    REG_C3_SLEWING_CIRCLE,
    REG_C3_SLEWING_SINGLETURN,
    REG_C3_TROLLEY_CIRCLE,
    REG_C3_TROLLEY_SINGLETURN,
    REG_C3_HOOK_CIRCLE,
    REG_C3_HOOK_SINGLETURN,
    
    REG_INPUT_NUM
};

static const mb_reg_t MB_INPUT_REGISTERS[REG_INPUT_NUM] = {
    {REG_SYSTEM_VERSION,       REG_TYPE_INPUT_REGISTER, 0, 0},    
    {REG_C0_STATION_ONLINE,      REG_TYPE_INPUT_REGISTER, 10, 0},
    {REG_C0_ENCODER_ONLINE,      REG_TYPE_INPUT_REGISTER, 11, 0},
    {REG_C0_UPDATE_TIMESTAMP_H,  REG_TYPE_INPUT_REGISTER, 12, 0},
    {REG_C0_UPDATE_TIMESTAMP_L,  REG_TYPE_INPUT_REGISTER, 13, 0},
    {REG_C0_SLEWING_CIRCLE,      REG_TYPE_INPUT_REGISTER, 14, 0},
    {REG_C0_SLEWING_SINGLETURN,  REG_TYPE_INPUT_REGISTER, 15, 0},
    {REG_C0_TROLLEY_CIRCLE,      REG_TYPE_INPUT_REGISTER, 16, 0},
    {REG_C0_TROLLEY_SINGLETURN,  REG_TYPE_INPUT_REGISTER, 17, 0},
    {REG_C0_HOOK_CIRCLE,         REG_TYPE_INPUT_REGISTER, 18, 0},
    {REG_C0_HOOK_SINGLETURN,     REG_TYPE_INPUT_REGISTER, 19, 0},
    {REG_C1_STATION_ONLINE,      REG_TYPE_INPUT_REGISTER, 20, 0},
    {REG_C1_ENCODER_ONLINE,      REG_TYPE_INPUT_REGISTER, 21, 0},
    {REG_C1_UPDATE_TIMESTAMP_H,  REG_TYPE_INPUT_REGISTER, 22, 0},
    {REG_C1_UPDATE_TIMESTAMP_L,  REG_TYPE_INPUT_REGISTER, 23, 0},
    {REG_C1_SLEWING_CIRCLE,      REG_TYPE_INPUT_REGISTER, 24, 0},
    {REG_C1_SLEWING_SINGLETURN,  REG_TYPE_INPUT_REGISTER, 25, 0},
    {REG_C1_TROLLEY_CIRCLE,      REG_TYPE_INPUT_REGISTER, 26, 0},
    {REG_C1_TROLLEY_SINGLETURN,  REG_TYPE_INPUT_REGISTER, 27, 0},
    {REG_C1_HOOK_CIRCLE,         REG_TYPE_INPUT_REGISTER, 28, 0},
    {REG_C1_HOOK_SINGLETURN,     REG_TYPE_INPUT_REGISTER, 29, 0},
    {REG_C2_STATION_ONLINE,      REG_TYPE_INPUT_REGISTER, 30, 0},
    {REG_C2_ENCODER_ONLINE,      REG_TYPE_INPUT_REGISTER, 31, 0},
    {REG_C2_UPDATE_TIMESTAMP_H,  REG_TYPE_INPUT_REGISTER, 32, 0},
    {REG_C2_UPDATE_TIMESTAMP_L,  REG_TYPE_INPUT_REGISTER, 33, 0},
    {REG_C2_SLEWING_CIRCLE,      REG_TYPE_INPUT_REGISTER, 34, 0},
    {REG_C2_SLEWING_SINGLETURN,  REG_TYPE_INPUT_REGISTER, 35, 0},
    {REG_C2_TROLLEY_CIRCLE,      REG_TYPE_INPUT_REGISTER, 36, 0},
    {REG_C2_TROLLEY_SINGLETURN,  REG_TYPE_INPUT_REGISTER, 37, 0},
    {REG_C2_HOOK_CIRCLE,         REG_TYPE_INPUT_REGISTER, 38, 0},
    {REG_C2_HOOK_SINGLETURN,     REG_TYPE_INPUT_REGISTER, 39, 0},
    {REG_C3_STATION_ONLINE,      REG_TYPE_INPUT_REGISTER, 40, 0},
    {REG_C3_ENCODER_ONLINE,      REG_TYPE_INPUT_REGISTER, 41, 0},
    {REG_C3_UPDATE_TIMESTAMP_H,  REG_TYPE_INPUT_REGISTER, 42, 0},
    {REG_C3_UPDATE_TIMESTAMP_L,  REG_TYPE_INPUT_REGISTER, 43, 0},
    {REG_C3_SLEWING_CIRCLE,      REG_TYPE_INPUT_REGISTER, 44, 0},
    {REG_C3_SLEWING_SINGLETURN,  REG_TYPE_INPUT_REGISTER, 45, 0},
    {REG_C3_TROLLEY_CIRCLE,      REG_TYPE_INPUT_REGISTER, 46, 0},
    {REG_C3_TROLLEY_SINGLETURN,  REG_TYPE_INPUT_REGISTER, 47, 0},
    {REG_C3_HOOK_CIRCLE,         REG_TYPE_INPUT_REGISTER, 48, 0},
    {REG_C3_HOOK_SINGLETURN,     REG_TYPE_INPUT_REGISTER, 49, 0},
};

enum {
    REG_MAIN_DHCP = 0,
    REG_MAIN_IP1,
    REG_MAIN_IP2,
    REG_MAIN_IP3,
    REG_MAIN_IP4,
    REG_MAIN_SN1,
    REG_MAIN_SN2,
    REG_MAIN_SN3,
    REG_MAIN_SN4,
    REG_MAIN_GW1,
    REG_MAIN_GW2,
    REG_MAIN_GW3,
    REG_MAIN_GW4,
    REG_MAIN_DNS1,
    REG_MAIN_DNS2,
    REG_MAIN_DNS3,
    REG_MAIN_DNS4,
    REG_HOLDING_NUM
};

static const mb_reg_t MB_HOLDING_REGISTERS[REG_HOLDING_NUM] = {
    {REG_MAIN_DHCP,  REG_TYPE_HOLDING_REGISTER, 0,   0},
    {REG_MAIN_IP1,   REG_TYPE_HOLDING_REGISTER, 1, 192},
    {REG_MAIN_IP2,   REG_TYPE_HOLDING_REGISTER, 2, 168},
    {REG_MAIN_IP3,   REG_TYPE_HOLDING_REGISTER, 3,   1},
    {REG_MAIN_IP4,   REG_TYPE_HOLDING_REGISTER, 4, 100},
    {REG_MAIN_SN1,   REG_TYPE_HOLDING_REGISTER, 5, 255},
    {REG_MAIN_SN2,   REG_TYPE_HOLDING_REGISTER, 6, 255},
    {REG_MAIN_SN3,   REG_TYPE_HOLDING_REGISTER, 7, 255},
    {REG_MAIN_SN4,   REG_TYPE_HOLDING_REGISTER, 8,   0},
    {REG_MAIN_GW1,   REG_TYPE_HOLDING_REGISTER, 9, 192},
    {REG_MAIN_GW2,   REG_TYPE_HOLDING_REGISTER,10, 168},
    {REG_MAIN_GW3,   REG_TYPE_HOLDING_REGISTER,11,   1},
    {REG_MAIN_GW4,   REG_TYPE_HOLDING_REGISTER,12,   1},
    {REG_MAIN_DNS1,  REG_TYPE_HOLDING_REGISTER,13, 192},
    {REG_MAIN_DNS2,  REG_TYPE_HOLDING_REGISTER,14, 168},
    {REG_MAIN_DNS3,  REG_TYPE_HOLDING_REGISTER,15,   1},
    {REG_MAIN_DNS4,  REG_TYPE_HOLDING_REGISTER,16,   1},
};

#ifdef __cplusplus
extern "C" {
#endif

mb_err_t mb_init_reg(void);
mb_err_t mb_clear_regs(int type);
mb_err_t mb_default_regs(int type);

mb_err_t mb_get_coil_reg_by_address(uint16_t address, uint8_t *value);
mb_err_t mb_set_coil_reg_by_address(uint16_t address, uint8_t value);
mb_err_t mb_get_holding_reg_by_address(uint16_t address, uint16_t *value);
mb_err_t mb_set_holding_reg_by_address(uint16_t address, uint16_t value);
mb_err_t mb_get_input_reg_by_address(uint16_t address, uint16_t *value);
mb_err_t mb_set_input_reg_by_address(uint16_t address, uint16_t value);

mb_err_t mb_get_reg_safe(const mb_reg_t *reg, void *value);
mb_err_t mb_set_reg_safe(const mb_reg_t *reg, const void *value);

// mb_err_t mb_save_to_flash(void);
// mb_err_t mb_load_from_flash(void);

#ifdef __cplusplus
}
#endif

#endif
