/*
 * lan8742a_modbus_tcp.c
 *
 *  Created on: Jul 16, 2025
 *      Author: sean (generated by AI assistant)
 *
 *  Simple Modbus-TCP slave implementation that runs on the internal
 *  LAN8742A Ethernet interface via the lwIP BSD-socket API. The server
 *  shares the same register map and callback mechanisms as the W5500
 *  version by delegating all protocol parsing to `modbus_protocol_handle()`.
 */

#include "modbus_tcp_server_task.h"

#include <stdint.h>
#include <string.h>

#include "main.h"
#include "cmsis_os.h"  

#include "lwip/sockets.h"
#include "lwip/netdb.h"
#include "lwip/inet.h"
#include "lwip/errno.h"
#include "lwip/tcp.h"

//#include "lfs.h"

#include "modbus_tcp_server_protocol.h" 

//extern lfs_t lfs_W25Q;
//extern lfs_file_t file_W25Q;
//extern const struct lfs_config cfg_W25Q;

#define MBTT_E(...) LOG_ERR("MBTT", __VA_ARGS__)
#define MBTT_I(...) LOG_INFO("MBTT", __VA_ARGS__)

#ifndef MBTCP_PORT
#define MBTCP_PORT 502            // Default port for Modbus-TCP
#endif

#define MODBUS_RX_BUF_LEN  260    // Enough for one complete Modbus-TCP PDU
#define MODBUS_TX_BUF_LEN  260

#define WORKER_TASK_STACK_SIZE 4096  // bytes for each per-client worker
#define SERVER_TASK_PRIORITY   (osPriority_t)osPriorityNormal

#define LAN8742A_MAX_CLIENTS 4
static volatile uint32_t active_clients = 0;

osThreadId_t modbus_tcp_server_handle;
const osThreadAttr_t modbus_tcp_server_attributes = {
    .name = "ModbusTCPServerTask",
    .stack_size = 2048 * 4,
    .priority = (osPriority_t)osPriorityNormal,
};


static int process_accumulated_frames(int sock, uint8_t *buf, int buf_len)
{
    uint8_t tx_buf[MODBUS_TX_BUF_LEN];

    int pos = 0;
    while (pos + 6 <= buf_len)   // need at least MBAP(6) to read Length
    {
        uint16_t pdu_len   = ((uint16_t)buf[pos + 4] << 8) | buf[pos + 5];
        uint16_t frame_len = (uint16_t)(pdu_len + 6);   // MBAP(6) + (UnitID + PDU)

        // Basic sanity checks: Length must at least cover UnitID(1)+Function(1) → 2 bytes
        // and overall frame must be within our RX buffer capability.
        if (pdu_len < 2 || frame_len < 8 || frame_len > MODBUS_RX_BUF_LEN)
        {
            printf("Modbus-TCP: invalid frame length (pdu=%u, frame=%u)", (unsigned)pdu_len, (unsigned)frame_len);
            return -1; // fatal for this connection
        }

        if (pos + frame_len > buf_len)
        {
            // Incomplete frame – leave remaining bytes in accumulator
            break; 
        }

        int resp_len = modbus_protocol_handle(&buf[pos], frame_len, tx_buf);
        if (resp_len > 0)
        {
            (void)send(sock, tx_buf, resp_len, 0);
        }
        pos += frame_len;   // advance to next frame (if any)
    }

    return pos; // bytes consumed from accumulator
}

// Apply basic receive timeout and TCP keepalive on a client socket
static void set_client_socket_opts(int client_fd)
{
    // Receive timeout: close idle connections to free worker
    #ifdef SO_RCVTIMEO
    {
        struct timeval tv;
        tv.tv_sec = 10;   // 10 seconds
        tv.tv_usec = 0;
        if (setsockopt(client_fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0)
        {
            printf("Modbus-TCP: SO_RCVTIMEO failed (%d)", errno);
        }
    }
    #endif

    int yes = 1;
    #ifdef SO_KEEPALIVE
    if (setsockopt(client_fd, SOL_SOCKET, SO_KEEPALIVE, &yes, sizeof(yes)) < 0)
    {
        printf("Modbus-TCP: SO_KEEPALIVE failed (%d)", errno);
    }
    #endif

    // Keepalive tuning (if supported by lwIP config)
    #if defined(IPPROTO_TCP) && defined(TCP_KEEPIDLE) && defined(TCP_KEEPINTVL) && defined(TCP_KEEPCNT)
    {
        int idle = 30;   // seconds before sending keepalive probes
        int intvl = 5;   // interval between probes
        int cnt = 3;     // number of failed probes before drop
        (void)setsockopt(client_fd, IPPROTO_TCP, TCP_KEEPIDLE, &idle, sizeof(idle));
        (void)setsockopt(client_fd, IPPROTO_TCP, TCP_KEEPINTVL, &intvl, sizeof(intvl));
        (void)setsockopt(client_fd, IPPROTO_TCP, TCP_KEEPCNT, &cnt, sizeof(cnt));
    }
    #endif
}

// Worker task handling a single Modbus-TCP client connection.
static void modbus_tcp_server_worker_task(void *argument)
{
    int client_fd = (int)(intptr_t)argument;
    uint8_t accum_buf[MODBUS_RX_BUF_LEN];
    int accum_len = 0;

    // Main receive loop with accumulation for sticky/partial frames
    while (1)
    {
        // Ensure there is space to receive
        int space = (int)sizeof(accum_buf) - accum_len;
        if (space <= 0)
        {
            printf("Modbus-TCP: accumulator overflow, closing client");
            break;
        }

        int received = recv(client_fd, (char*)accum_buf + accum_len, (size_t)space, 0);
        if (received > 0)
        {
            accum_len += received;

            int consumed = process_accumulated_frames(client_fd, accum_buf, accum_len);
            if (consumed < 0)
            {
                // fatal parsing error, drop connection
                break;
            }
            if (consumed > 0)
            {
                // Shift remaining bytes to the front
                memmove(accum_buf, accum_buf + consumed, (size_t)(accum_len - consumed));
                accum_len -= consumed;
            }
        }
        else if (received == 0)
        {
            break; // connection closed or error
        }
        else
        {
            // Error path
            if (errno == EWOULDBLOCK)
            {
                printf("Modbus-TCP: recv timeout, closing idle client");
            }
            else
            {
                printf("Modbus-TCP: recv failed (%d), closing client", errno);
            }
            break;
        }
    }

    closesocket(client_fd);
    if (active_clients > 0) {
        active_clients--; // atomic enough on Cortex-M single core
    }
    printf("Modbus-TCP: client task exit, active=%lu", active_clients);
    vTaskDelete(NULL);
}


void lan8742a_modbus_tcp_server_task(void *argument)
{
    (void)argument;

    int server_fd = -1;

    // Create listening socket
    server_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
    if (server_fd < 0) {
        printf("Modbus-TCP: failed to create socket (%d)", errno);
        goto exit_task;
    }

    int opt = 1;
    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in srv_addr;
    memset(&srv_addr, 0, sizeof(srv_addr));
    srv_addr.sin_family      = AF_INET;
    srv_addr.sin_addr.s_addr = INADDR_ANY;
    srv_addr.sin_port        = htons(MBTCP_PORT);

    if (bind(server_fd, (struct sockaddr *)&srv_addr, sizeof(srv_addr)) < 0) {
        printf("Modbus-TCP: bind() failed (%d)", errno);
        goto cleanup_socket;
    }

    if (listen(server_fd, LAN8742A_MAX_CLIENTS) < 0) {
        printf("Modbus-TCP: listen() failed (%d)", errno);
        goto cleanup_socket;
    }

    printf("Modbus-TCP slave ready (up to %d clients)", LAN8742A_MAX_CLIENTS);

    while (1)
    {
        struct sockaddr_in client_addr;
        socklen_t addr_len = sizeof(client_addr);
        int client_fd = accept(server_fd, (struct sockaddr *)&client_addr, &addr_len);
        if (client_fd < 0) {
            osDelay(10);
            continue;
        }

        if (active_clients >= LAN8742A_MAX_CLIENTS) {
            printf("Modbus-TCP: too many clients (%lu)", active_clients);
            closesocket(client_fd);
            continue;
        }

        printf("Modbus-TCP: client %s:%u connected (active=%lu)",
                     inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port), active_clients + 1);

        // Configure client socket options (timeout + keepalive)
        set_client_socket_opts(client_fd);

        active_clients++;

        const osThreadAttr_t attr = {
            .name       = "ModbusClient",
            .stack_size = WORKER_TASK_STACK_SIZE,
            .priority   = SERVER_TASK_PRIORITY,
        };
        osThreadId_t tid = osThreadNew(modbus_tcp_server_worker_task, (void *)(intptr_t)client_fd, &attr);
        if (tid == NULL) {
            printf("Failed to create client task");
            active_clients--;
            closesocket(client_fd);
        }
    }

cleanup_socket:
    if (server_fd >= 0) {
        closesocket(server_fd);
    }
exit_task:
    printf("Modbus-TCP task exiting – will suspend.");
    vTaskSuspend(NULL);
}

void modbus_tcp_init_server(void)
{

//  int err = lfs_mount(&lfs_W25Q, &cfg_W25Q);
//  if (err != 0)
//  {
//    MBTT_I("lfs", "mount failed (%d), formatting...\r\n", err);
//
//    err = lfs_format(&lfs_W25Q, &cfg_W25Q);
//    if (err != 0)
//    {
//      MBTT_I("lfs", "format failed (%d)\r\n", err);
//    }
//    else
//    {
//      err = lfs_mount(&lfs_W25Q, &cfg_W25Q);
//      if (err != 0)
//      {
//        MBTT_E("lfs", "mount failed after format (%d),use default value without save\r\n", err);
//      }
//    }
//  }
  
  mb_init_reg();
  
  modbus_tcp_server_handle = osThreadNew(lan8742a_modbus_tcp_server_task, NULL, &modbus_tcp_server_attributes);
  if (modbus_tcp_server_handle == NULL)
  {
    MBTT_E("sys", "Failed to create Device Service Task\r\n");
  }
}
